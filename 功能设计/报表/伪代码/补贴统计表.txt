/**
 * 补贴统计表获取页面数据（刷新功能）
 * 方法名称和变量名可以在代码阶段进行调整，这里只是为了提高可读性
 */
public List<Map> getWorkHourByMonth() {
	/* 变量定义 */
	List 维修工时明细列表,清洁工时明细列表,人员工时汇总列表;
	String 维修总工时,维修总金额,维修单价,清洁总工时,清洁总金额,清洁单价;
	float temp工时,temp金额,temp按人员工时;
	Map temp人员工时,工时单价;
	
	/* 0.获取工时单价信息 */
	工时单价 = 获取工时单价数据（按照机构代码获取）;
	工时单价不存在时，工时单价当成0处理;
	
	/* 1.处理维修工时明细列表 */
	维修工时明细列表 = 获取维修工时明细列表数据;
	if(维修工时明细列表有数据){
		for(维修工时明细列表:维修工时明细数据){
			temp工时 = temp工时 + 维修工时明细数据.工时;
			temp金额 = temp金额 + 维修工时明细数据.金额;
			if(temp人员工时中存在key=维修工时明细数据.userno){
				temp人员工时.get(维修工时明细数据.userno) + 维修工时明细数据.工时;//更新人员的工时累计
			}else{
				temp人员工时.put(维修工时明细数据.userno,维修工时明细数据.工时);
			}
		}
		//计算人员工时费用
		如果维修工时单价无数据，那么人员维修工时费用 = 0
		如果维修工时单价只有一条数据，那么人员维修工时费用 = temp人员工时.get(维修工时明细数据.userno) * 工时单价（计算结果保留两位小数）
		如果维修工时单价大于一条数据，那么先根据temp人员工时.get(维修工时明细数据.userno)匹配到合适的数据（大于起算工时，并且小于等于截止工时），一定匹配的上一条数据。
		在拿这条数据的值来计算：人员维修工时费用 = （temp人员工时.get(维修工时明细数据.userno) - 起算工时）* 工时单价 + 前端金额（计算结果保留两位小数）
	}
	
	/* 2.处理清洁工时明细列表 */
	清洁工时明细列表 = 获取清洁工时明细列表数据;
	if(清洁工时明细列表有数据){
		for(清洁工时明细列表:清洁工时明细数据){
			temp工时 = temp工时 + 清洁工时明细数据.工时;
			temp金额 = temp金额 + 清洁工时明细数据.金额;
			if(temp人员工时中存在key=清洁工时明细数据.userno){
				temp人员工时.get(清洁工时明细数据.userno) + 清洁工时明细数据.工时;//更新人员的工时累计
			}else{
				temp人员工时.put(清洁工时明细数据.userno,清洁工时明细数据.工时);
			}
		}
		//计算人员工时费用
		如果清洁工时单价无数据，那么人员清洁工时费用 = 0
		如果清洁工时单价只有一条数据，那么人员清洁工时费用 = temp人员工时.get(清洁工时明细数据.userno) * 工时单价（计算结果保留两位小数）
		如果清洁工时单价大于一条数据，那么先根据temp人员工时.get(清洁工时明细数据.userno)匹配到合适的数据（大于起算工时，并且小于等于截止工时），一定匹配的上一条数据。
		在拿这条数据的值来计算：人员清洁工时费用 = （temp人员工时.get(清洁工时明细数据.userno) - 起算工时）* 工时单价 + 前端金额（计算结果保留两位小数）
	}
	
	/* 3.组装数据返回 */
	之中需要注意，只有人员工时汇总列表是将两个集合中的人员合并，相同人员的就做加法：人员工时金额=人员维修工时费用 + 人员清洁工时费用;
	排序：人员工时汇总列表按照人员姓名
}